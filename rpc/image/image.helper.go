// Code generated by nerdynz/builder. DO NOT EDIT.
// versions:
// 	builder        v1.0.0
// source: image.proto

package image

import (
	"context"
	"errors"
	"slices"
	"strings"
	"time"

	"github.com/nerdynz/datastore"
	base "github.com/nerdynz/skeleton/rpc/base"
)

var clientHelperGlobal *ImageHelper

type ImageHelper struct {
	ds *datastore.Datastore
	// fieldNames []string
	// orderBy    string
}

func NewImageHelper(datastore *datastore.Datastore) *ImageHelper {
	if clientHelperGlobal == nil {
		clientHelperGlobal = newImageHelper(datastore)
	}
	return clientHelperGlobal
}

func newImageHelper(datastore *datastore.Datastore) *ImageHelper {
	helper := &ImageHelper{
		ds: datastore,
	}
	return helper
}

func (h *ImageHelper) New(siteUlid string) *Image {
	record := &Image{}
	// check DateCreated
	record.DateCreated = time.Now().Format(time.RFC3339)
	record.SiteUlid = siteUlid
	return record
}

func (h *ImageHelper) Load(ctx context.Context, ulid string) (*Image, error) {
	record, err := h.One(ctx, "where image_ulid = $1 and $SITEULID", ulid)
	if err != nil {
		return nil, err
	}
	return record, nil
}

func (h *ImageHelper) All(ctx context.Context) ([]*Image, error) {
	siteUlid := ctx.Value("site_ulid").(string)
	var records []*Image

	sql := h.selectFrom()
	sql += `where site_ulid = $1 order by ` + h.orderBy()

	err := h.ds.Select(ctx, &records, sql, siteUlid)
	if err != nil {
		return nil, err
	}
	return records, nil
}

func (h *ImageHelper) Where(ctx context.Context, sql string, args ...interface{}) ([]*Image, error) {
	s := h.selectFrom()
	s += " " + sql + " "
	s += ` order by ` + h.orderBy() // NOTE: be careful sql inj
	s += " limit 1"

	records, err := h.SQL(ctx, s, args...)
	if err != nil {
		return nil, err
	}
	return records, nil
}

func (h *ImageHelper) SQL(ctx context.Context, sql string, args ...interface{}) ([]*Image, error) {
	siteUlid := ctx.Value("site_ulid").(string)

	if !strings.Contains(sql, "$SITEULID") {
		return nil, errors.New("No $SITEULID placeholder defined")
	}
	var records []*Image
	sql, args, err := datastore.AppendSiteULID(siteUlid, sql, args...)
	if err != nil {
		return nil, err
	}
	err = h.ds.Select(ctx, &records, sql, args...)
	if err != nil {
		return nil, err
	}
	return records, nil
}

func (h *ImageHelper) One(ctx context.Context, sql string, args ...interface{}) (*Image, error) {
	s := h.selectFrom()
	s += " " + sql + " "
	s += ` order by ` + h.orderBy() // NOTE: be careful sql inj
	s += " limit 1"

	records, err := h.SQL(ctx, s, args...)
	if err != nil {
		return nil, err
	}
	if len(records) != 1 {
		return nil, errors.New("Failed to fetch only one record")
	}
	return records[0], nil
}

func (h *ImageHelper) PagedBy(ctx context.Context, pageNum int32, itemsPerPage int32, orderByFieldName string, direction string, searchText string) (*ImagesPaged, error) {
	siteUlid := ctx.Value("site_ulid").(string)

	if orderByFieldName == "" || orderByFieldName == "default" {
		// we only want the first field name
		orderByFieldName = strings.Split(h.orderBy(), ",")[0]
		orderByFieldName = strings.Trim(orderByFieldName, " ")
	}

	// check the orderby exists within the fields as this could be an easy sql injection hole.
	if !slices.Contains(h.fieldNames(), orderByFieldName) { // NOT
		return nil, errors.New("field name [" + orderByFieldName + "]  isn't a valid field name")
	}

	direction = strings.ToLower(direction)
	if direction == "none" {
		direction = ""
	}
	if !(direction == "asc" || direction == "desc" || direction == "") {
		return nil, errors.New("direction isn't valid")
	}

	offset := (pageNum - 1) * itemsPerPage

	sql := h.selectFrom()
	sql += " where site_ulid = $1"
	if searchText == "" {
		sql += " and ($2='')"
	} else {
		sql += " and ($2 = '' or tsv @@ to_tsquery($2))"
	}

	// above does the sql injection check for this
	sql += " order by " + orderByFieldName + " " + direction

	sql += " offset $3 "
	sql += " limit $4 "

	var records []*Image
	err := h.ds.Select(ctx, &records, sql, siteUlid, datastore.FormatSearch(searchText), offset, itemsPerPage)
	if err != nil {
		return nil, err
	}

	dirEnum := base.PagedInfo_NONE
	switch strings.ToUpper(direction) {
	case base.PagedInfo_ASC.String():
		dirEnum = base.PagedInfo_ASC
	case base.PagedInfo_DESC.String():
		dirEnum = base.PagedInfo_DESC
	}

	count := int32(0)
	h.ds.One(ctx, &count, `select count(image_ulid) from image where site_ulid = $1`, siteUlid)
	paged := &base.PagedInfo{
		PageNumber: pageNum,
		OrderBy:    orderByFieldName,
		Direction:  dirEnum,
		Limit:      itemsPerPage,
		Total:      count,
		Search:     searchText,
	}
	return &ImagesPaged{
		PagedInfo: paged,
		Records:   records,
	}, nil
}

func (h *ImageHelper) save(ctx context.Context, record *Image) error {
	siteUlid := ctx.Value("site_ulid").(string)
	err := h.beforeSave(record)
	if err != nil {
		return err
	}
	if record.SiteUlid != siteUlid {
		return errors.New("*Image update failed. SITEULID Mismatch")
	}
	sql := `
	INSERT INTO image (image_ulid, image, original_height, original_width, top, left, scale, crop_height, crop_width, site_ulid, date_created, date_modified, is_processed) 
	VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
	ON CONFLICT (image_ulid) 
	DO UPDATE SET image = EXCLUDED.image, original_height = EXCLUDED.original_height, original_width = EXCLUDED.original_width, top = EXCLUDED.top, left = EXCLUDED.left, scale = EXCLUDED.scale, crop_height = EXCLUDED.crop_height, crop_width = EXCLUDED.crop_width, date_created = EXCLUDED.date_created, date_modified = EXCLUDED.date_modified, is_processed = EXCLUDED.is_processed
	`
	_, err = h.ds.Exec(ctx, sql, record.ImageUlid, record.Image, record.OriginalHeight, record.OriginalWidth, record.Top, record.Left, record.Scale, record.CropHeight, record.CropWidth, record.SiteUlid, record.DateCreated, record.DateModified, record.IsProcessed)
	if err != nil {
		return err
	}
	err = h.afterSave(record)
	return err
}

func (h *ImageHelper) Delete(ctx context.Context, recordUlid string) (bool, error) {
	siteUlid := ctx.Value("site_ulid").(string)
	result, err := h.ds.Exec(ctx, `
	DELETE FROM image  
	WHERE site_ulid=$1 and image_ulid=$2
	`, siteUlid, recordUlid)
	if err != nil {
		return false, err
	}
	return (result.RowsAffected() > 0), nil
}

//func (image *Image) SaveUnusedImages(siteUlid string) error {
//	return UnusedImagesHelper().SaveMany(siteUlid, image.UnusedImages)
//}
//
//func (image *Image) LoadUnusedImages(siteUlid string) error {
//	return image.LoadUnusedImagesWhere(siteUlid, "image_ulid = $1 $SITEULID", image.ImageULID)
//}
//
//func (image *Image) LoadUnusedImagesWhere(siteUlid string, sql string, args ...interface{}) error {
//	children, err := UnusedImagesHelper().Where(siteUlid, sql, args...)
//	if err != nil {
//		return err
//	}
//	image.UnusedImages = children
//	return nil
//}
