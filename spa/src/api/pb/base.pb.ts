// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: base.proto

import type { ByteSource } from "twirpscript";
import { BinaryReader, BinaryWriter } from "twirpscript";

//========================================//
//                 Types                  //
//========================================//

export interface Empty {}

export interface Lookup {
  ulid: string;
}

export interface Deleted {
  isDeleted: boolean;
}

export interface PagedInfo {
  pageNumber: number;
  limit: number;
  orderBy: string;
  direction: PagedInfo.Direction;
  total: number;
  search: string;
}

declare namespace PagedInfo {
  export type Direction = "NONE" | "ASC" | "DESC";
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Empty = {
  /**
   * Serializes a Empty to protobuf.
   */
  encode: function (_msg?: Partial<Empty>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a Empty from protobuf.
   */
  decode: function (_bytes?: ByteSource): Empty {
    return {};
  },

  /**
   * Serializes a Empty to JSON.
   */
  encodeJSON: function (_msg?: Partial<Empty>): string {
    return "{}";
  },

  /**
   * Deserializes a Empty from JSON.
   */
  decodeJSON: function (_json?: string): Empty {
    return {};
  },

  /**
   * Initializes a Empty with all fields set to their default value.
   */
  initialize: function (): Empty {
    return {};
  },
};

export const Lookup = {
  /**
   * Serializes a Lookup to protobuf.
   */
  encode: function (msg: Partial<Lookup>): Uint8Array {
    return Lookup._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Lookup from protobuf.
   */
  decode: function (bytes: ByteSource): Lookup {
    return Lookup._readMessage(Lookup.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Lookup to JSON.
   */
  encodeJSON: function (msg: Partial<Lookup>): string {
    return JSON.stringify(Lookup._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Lookup from JSON.
   */
  decodeJSON: function (json: string): Lookup {
    return Lookup._readMessageJSON(Lookup.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Lookup with all fields set to their default value.
   */
  initialize: function (): Lookup {
    return {
      ulid: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Lookup>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.ulid) {
      writer.writeString(1, msg.ulid);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Lookup>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.ulid) {
      json.ulid = msg.ulid;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Lookup, reader: BinaryReader): Lookup {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.ulid = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Lookup, json: any): Lookup {
    const _ulid = json.ulid;
    if (_ulid) {
      msg.ulid = _ulid;
    }
    return msg;
  },
};

export const Deleted = {
  /**
   * Serializes a Deleted to protobuf.
   */
  encode: function (msg: Partial<Deleted>): Uint8Array {
    return Deleted._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Deleted from protobuf.
   */
  decode: function (bytes: ByteSource): Deleted {
    return Deleted._readMessage(Deleted.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Deleted to JSON.
   */
  encodeJSON: function (msg: Partial<Deleted>): string {
    return JSON.stringify(Deleted._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Deleted from JSON.
   */
  decodeJSON: function (json: string): Deleted {
    return Deleted._readMessageJSON(Deleted.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Deleted with all fields set to their default value.
   */
  initialize: function (): Deleted {
    return {
      isDeleted: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Deleted>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.isDeleted) {
      writer.writeBool(1, msg.isDeleted);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Deleted>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.isDeleted) {
      json.isDeleted = msg.isDeleted;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Deleted, reader: BinaryReader): Deleted {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.isDeleted = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Deleted, json: any): Deleted {
    const _isDeleted = json.isDeleted ?? json.is_deleted;
    if (_isDeleted) {
      msg.isDeleted = _isDeleted;
    }
    return msg;
  },
};

export const PagedInfo = {
  /**
   * Serializes a PagedInfo to protobuf.
   */
  encode: function (msg: Partial<PagedInfo>): Uint8Array {
    return PagedInfo._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a PagedInfo from protobuf.
   */
  decode: function (bytes: ByteSource): PagedInfo {
    return PagedInfo._readMessage(
      PagedInfo.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a PagedInfo to JSON.
   */
  encodeJSON: function (msg: Partial<PagedInfo>): string {
    return JSON.stringify(PagedInfo._writeMessageJSON(msg));
  },

  /**
   * Deserializes a PagedInfo from JSON.
   */
  decodeJSON: function (json: string): PagedInfo {
    return PagedInfo._readMessageJSON(PagedInfo.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a PagedInfo with all fields set to their default value.
   */
  initialize: function (): PagedInfo {
    return {
      pageNumber: 0,
      limit: 0,
      orderBy: "",
      direction: PagedInfo.DirectionFromInt(0),
      total: 0,
      search: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<PagedInfo>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.pageNumber) {
      writer.writeInt32(1, msg.pageNumber);
    }
    if (msg.limit) {
      writer.writeInt32(2, msg.limit);
    }
    if (msg.orderBy) {
      writer.writeString(3, msg.orderBy);
    }
    if (msg.direction && PagedInfo.DirectionToInt(msg.direction)) {
      writer.writeEnum(4, PagedInfo.DirectionToInt(msg.direction));
    }
    if (msg.total) {
      writer.writeInt32(5, msg.total);
    }
    if (msg.search) {
      writer.writeString(6, msg.search);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<PagedInfo>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.pageNumber) {
      json.pageNumber = msg.pageNumber;
    }
    if (msg.limit) {
      json.limit = msg.limit;
    }
    if (msg.orderBy) {
      json.orderBy = msg.orderBy;
    }
    if (msg.direction && PagedInfo.DirectionToInt(msg.direction)) {
      json.direction = msg.direction;
    }
    if (msg.total) {
      json.total = msg.total;
    }
    if (msg.search) {
      json.search = msg.search;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: PagedInfo, reader: BinaryReader): PagedInfo {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.pageNumber = reader.readInt32();
          break;
        }
        case 2: {
          msg.limit = reader.readInt32();
          break;
        }
        case 3: {
          msg.orderBy = reader.readString();
          break;
        }
        case 4: {
          msg.direction = PagedInfo.DirectionFromInt(reader.readEnum());
          break;
        }
        case 5: {
          msg.total = reader.readInt32();
          break;
        }
        case 6: {
          msg.search = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: PagedInfo, json: any): PagedInfo {
    const _pageNumber = json.pageNumber ?? json.page_number;
    if (_pageNumber) {
      msg.pageNumber = _pageNumber;
    }
    const _limit = json.limit;
    if (_limit) {
      msg.limit = _limit;
    }
    const _orderBy = json.orderBy ?? json.order_by;
    if (_orderBy) {
      msg.orderBy = _orderBy;
    }
    const _direction = json.direction;
    if (_direction) {
      msg.direction = _direction;
    }
    const _total = json.total;
    if (_total) {
      msg.total = _total;
    }
    const _search = json.search;
    if (_search) {
      msg.search = _search;
    }
    return msg;
  },

  Direction: { NONE: "NONE", ASC: "ASC", DESC: "DESC" } as const,

  DirectionFromInt: function (i: number): PagedInfo.Direction {
    switch (i) {
      case 0: {
        return "NONE";
      }
      case 1: {
        return "ASC";
      }
      case 2: {
        return "DESC";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as PagedInfo.Direction;
      }
    }
  },

  DirectionToInt: function (i: PagedInfo.Direction): number {
    switch (i) {
      case "NONE": {
        return 0;
      }
      case "ASC": {
        return 1;
      }
      case "DESC": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
};
