// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: base.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import * as protoscript from "protoscript";

//========================================//
//                 Types                  //
//========================================//

export interface Empty {}

export interface Lookup {
  ulid: string;
}

export interface Deleted {
  isDeleted: boolean;
}

export interface PagedInfo {
  pageNumber: number;
  limit: number;
  orderBy: string;
  direction: PagedInfo.Direction;
  total: number;
  search: string;
}

export declare namespace PagedInfo {
  export type Direction = "NONE" | "ASC" | "DESC";
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Empty = {
  /**
   * Serializes Empty to protobuf.
   */
  encode: function (_msg?: PartialDeep<Empty>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes Empty from protobuf.
   */
  decode: function (_bytes?: ByteSource): Empty {
    return {};
  },

  /**
   * Initializes Empty with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Empty>): Empty {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<Empty>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: Empty,
    _reader: protoscript.BinaryReader,
  ): Empty {
    return _msg;
  },
};

export const Lookup = {
  /**
   * Serializes Lookup to protobuf.
   */
  encode: function (msg: PartialDeep<Lookup>): Uint8Array {
    return Lookup._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Lookup from protobuf.
   */
  decode: function (bytes: ByteSource): Lookup {
    return Lookup._readMessage(
      Lookup.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Lookup with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Lookup>): Lookup {
    return {
      ulid: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Lookup>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.ulid) {
      writer.writeString(1, msg.ulid);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Lookup,
    reader: protoscript.BinaryReader,
  ): Lookup {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.ulid = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Deleted = {
  /**
   * Serializes Deleted to protobuf.
   */
  encode: function (msg: PartialDeep<Deleted>): Uint8Array {
    return Deleted._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Deleted from protobuf.
   */
  decode: function (bytes: ByteSource): Deleted {
    return Deleted._readMessage(
      Deleted.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Deleted with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Deleted>): Deleted {
    return {
      isDeleted: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Deleted>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.isDeleted) {
      writer.writeBool(1, msg.isDeleted);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Deleted,
    reader: protoscript.BinaryReader,
  ): Deleted {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.isDeleted = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PagedInfo = {
  /**
   * Serializes PagedInfo to protobuf.
   */
  encode: function (msg: PartialDeep<PagedInfo>): Uint8Array {
    return PagedInfo._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PagedInfo from protobuf.
   */
  decode: function (bytes: ByteSource): PagedInfo {
    return PagedInfo._readMessage(
      PagedInfo.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PagedInfo with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PagedInfo>): PagedInfo {
    return {
      pageNumber: 0,
      limit: 0,
      orderBy: "",
      direction: PagedInfo.Direction._fromInt(0),
      total: 0,
      search: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PagedInfo>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.pageNumber) {
      writer.writeInt32(1, msg.pageNumber);
    }
    if (msg.limit) {
      writer.writeInt32(2, msg.limit);
    }
    if (msg.orderBy) {
      writer.writeString(3, msg.orderBy);
    }
    if (msg.direction && PagedInfo.Direction._toInt(msg.direction)) {
      writer.writeEnum(4, PagedInfo.Direction._toInt(msg.direction));
    }
    if (msg.total) {
      writer.writeInt32(5, msg.total);
    }
    if (msg.search) {
      writer.writeString(6, msg.search);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PagedInfo,
    reader: protoscript.BinaryReader,
  ): PagedInfo {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.pageNumber = reader.readInt32();
          break;
        }
        case 2: {
          msg.limit = reader.readInt32();
          break;
        }
        case 3: {
          msg.orderBy = reader.readString();
          break;
        }
        case 4: {
          msg.direction = PagedInfo.Direction._fromInt(reader.readEnum());
          break;
        }
        case 5: {
          msg.total = reader.readInt32();
          break;
        }
        case 6: {
          msg.search = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Direction: {
    NONE: "NONE",
    ASC: "ASC",
    DESC: "DESC",
    /**
     * @private
     */
    _fromInt: function (i: number): PagedInfo.Direction {
      switch (i) {
        case 0: {
          return "NONE";
        }
        case 1: {
          return "ASC";
        }
        case 2: {
          return "DESC";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as PagedInfo.Direction;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: PagedInfo.Direction): number {
      switch (i) {
        case "NONE": {
          return 0;
        }
        case "ASC": {
          return 1;
        }
        case "DESC": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const EmptyJSON = {
  /**
   * Serializes Empty to JSON.
   */
  encode: function (_msg?: PartialDeep<Empty>): string {
    return "{}";
  },

  /**
   * Deserializes Empty from JSON.
   */
  decode: function (_json?: string): Empty {
    return {};
  },

  /**
   * Initializes Empty with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Empty>): Empty {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (_msg: PartialDeep<Empty>): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: Empty, _json: any): Empty {
    return msg;
  },
};

export const LookupJSON = {
  /**
   * Serializes Lookup to JSON.
   */
  encode: function (msg: PartialDeep<Lookup>): string {
    return JSON.stringify(LookupJSON._writeMessage(msg));
  },

  /**
   * Deserializes Lookup from JSON.
   */
  decode: function (json: string): Lookup {
    return LookupJSON._readMessage(LookupJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Lookup with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Lookup>): Lookup {
    return {
      ulid: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Lookup>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.ulid) {
      json["ulid"] = msg.ulid;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Lookup, json: any): Lookup {
    const _ulid_ = json["ulid"];
    if (_ulid_) {
      msg.ulid = _ulid_;
    }
    return msg;
  },
};

export const DeletedJSON = {
  /**
   * Serializes Deleted to JSON.
   */
  encode: function (msg: PartialDeep<Deleted>): string {
    return JSON.stringify(DeletedJSON._writeMessage(msg));
  },

  /**
   * Deserializes Deleted from JSON.
   */
  decode: function (json: string): Deleted {
    return DeletedJSON._readMessage(DeletedJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Deleted with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Deleted>): Deleted {
    return {
      isDeleted: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Deleted>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.isDeleted) {
      json["isDeleted"] = msg.isDeleted;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Deleted, json: any): Deleted {
    const _isDeleted_ = json["isDeleted"] ?? json["is_deleted"];
    if (_isDeleted_) {
      msg.isDeleted = _isDeleted_;
    }
    return msg;
  },
};

export const PagedInfoJSON = {
  /**
   * Serializes PagedInfo to JSON.
   */
  encode: function (msg: PartialDeep<PagedInfo>): string {
    return JSON.stringify(PagedInfoJSON._writeMessage(msg));
  },

  /**
   * Deserializes PagedInfo from JSON.
   */
  decode: function (json: string): PagedInfo {
    return PagedInfoJSON._readMessage(
      PagedInfoJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PagedInfo with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PagedInfo>): PagedInfo {
    return {
      pageNumber: 0,
      limit: 0,
      orderBy: "",
      direction: PagedInfo.Direction._fromInt(0),
      total: 0,
      search: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PagedInfo>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.pageNumber) {
      json["pageNumber"] = msg.pageNumber;
    }
    if (msg.limit) {
      json["limit"] = msg.limit;
    }
    if (msg.orderBy) {
      json["orderBy"] = msg.orderBy;
    }
    if (msg.direction && PagedInfoJSON.Direction._toInt(msg.direction)) {
      json["direction"] = msg.direction;
    }
    if (msg.total) {
      json["total"] = msg.total;
    }
    if (msg.search) {
      json["search"] = msg.search;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: PagedInfo, json: any): PagedInfo {
    const _pageNumber_ = json["pageNumber"] ?? json["page_number"];
    if (_pageNumber_) {
      msg.pageNumber = protoscript.parseNumber(_pageNumber_);
    }
    const _limit_ = json["limit"];
    if (_limit_) {
      msg.limit = protoscript.parseNumber(_limit_);
    }
    const _orderBy_ = json["orderBy"] ?? json["order_by"];
    if (_orderBy_) {
      msg.orderBy = _orderBy_;
    }
    const _direction_ = json["direction"];
    if (_direction_) {
      msg.direction = PagedInfo.Direction._fromInt(_direction_);
    }
    const _total_ = json["total"];
    if (_total_) {
      msg.total = protoscript.parseNumber(_total_);
    }
    const _search_ = json["search"];
    if (_search_) {
      msg.search = _search_;
    }
    return msg;
  },

  Direction: {
    NONE: "NONE",
    ASC: "ASC",
    DESC: "DESC",
    /**
     * @private
     */
    _fromInt: function (i: number): PagedInfo.Direction {
      switch (i) {
        case 0: {
          return "NONE";
        }
        case 1: {
          return "ASC";
        }
        case 2: {
          return "DESC";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as PagedInfo.Direction;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: PagedInfo.Direction): number {
      switch (i) {
        case "NONE": {
          return 0;
        }
        case "ASC": {
          return 1;
        }
        case "DESC": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};
