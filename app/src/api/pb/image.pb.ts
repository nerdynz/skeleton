// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: image.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import * as protoscript from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `npx twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";
import * as base from "./base.pb";

//========================================//
//                 Types                  //
//========================================//

export interface Image {
  imageUlid: string;
  image: string;
  originalHeight: number;
  originalWidth: number;
  top: number;
  left: number;
  scale: number;
  cropHeight: number;
  cropWidth: number;
  siteUlid: string;
  dateCreated: string;
  dateModified: string;
  isProcessed: boolean;
}

export interface Images {
  images: Image[];
}

export interface ImagesPaged {
  pagedInfo: base.PagedInfo;
  records: Image[];
}

//========================================//
//        ImageRPC Protobuf Client        //
//========================================//

export async function LoadImage(
  lookup: base.Lookup,
  config?: ClientConfiguration,
): Promise<Image> {
  const response = await PBrequest(
    "/skeleton.ImageRPC/LoadImage",
    base.Lookup.encode(lookup),
    config,
  );
  return Image.decode(response);
}

export async function SaveImage(
  image: Image,
  config?: ClientConfiguration,
): Promise<Image> {
  const response = await PBrequest(
    "/skeleton.ImageRPC/SaveImage",
    Image.encode(image),
    config,
  );
  return Image.decode(response);
}

export async function PagedImages(
  pagedInfo: base.PagedInfo,
  config?: ClientConfiguration,
): Promise<ImagesPaged> {
  const response = await PBrequest(
    "/skeleton.ImageRPC/PagedImages",
    base.PagedInfo.encode(pagedInfo),
    config,
  );
  return ImagesPaged.decode(response);
}

export async function DeleteImage(
  lookup: base.Lookup,
  config?: ClientConfiguration,
): Promise<base.Deleted> {
  const response = await PBrequest(
    "/skeleton.ImageRPC/DeleteImage",
    base.Lookup.encode(lookup),
    config,
  );
  return base.Deleted.decode(response);
}

//========================================//
//          ImageRPC JSON Client          //
//========================================//

export async function LoadImageJSON(
  lookup: base.Lookup,
  config?: ClientConfiguration,
): Promise<Image> {
  const response = await JSONrequest(
    "/skeleton.ImageRPC/LoadImage",
    base.LookupJSON.encode(lookup),
    config,
  );
  return ImageJSON.decode(response);
}

export async function SaveImageJSON(
  image: Image,
  config?: ClientConfiguration,
): Promise<Image> {
  const response = await JSONrequest(
    "/skeleton.ImageRPC/SaveImage",
    ImageJSON.encode(image),
    config,
  );
  return ImageJSON.decode(response);
}

export async function PagedImagesJSON(
  pagedInfo: base.PagedInfo,
  config?: ClientConfiguration,
): Promise<ImagesPaged> {
  const response = await JSONrequest(
    "/skeleton.ImageRPC/PagedImages",
    base.PagedInfoJSON.encode(pagedInfo),
    config,
  );
  return ImagesPagedJSON.decode(response);
}

export async function DeleteImageJSON(
  lookup: base.Lookup,
  config?: ClientConfiguration,
): Promise<base.Deleted> {
  const response = await JSONrequest(
    "/skeleton.ImageRPC/DeleteImage",
    base.LookupJSON.encode(lookup),
    config,
  );
  return base.DeletedJSON.decode(response);
}

//========================================//
//                ImageRPC                //
//========================================//

export interface ImageRPC<Context = unknown> {
  LoadImage: (lookup: base.Lookup, context: Context) => Promise<Image> | Image;
  SaveImage: (image: Image, context: Context) => Promise<Image> | Image;
  PagedImages: (
    pagedInfo: base.PagedInfo,
    context: Context,
  ) => Promise<ImagesPaged> | ImagesPaged;
  DeleteImage: (
    lookup: base.Lookup,
    context: Context,
  ) => Promise<base.Deleted> | base.Deleted;
}

export function createImageRPC<Context>(service: ImageRPC<Context>) {
  return {
    name: "skeleton.ImageRPC",
    methods: {
      LoadImage: {
        name: "LoadImage",
        handler: service.LoadImage,
        input: { protobuf: base.Lookup, json: base.LookupJSON },
        output: { protobuf: Image, json: ImageJSON },
      },
      SaveImage: {
        name: "SaveImage",
        handler: service.SaveImage,
        input: { protobuf: Image, json: ImageJSON },
        output: { protobuf: Image, json: ImageJSON },
      },
      PagedImages: {
        name: "PagedImages",
        handler: service.PagedImages,
        input: { protobuf: base.PagedInfo, json: base.PagedInfoJSON },
        output: { protobuf: ImagesPaged, json: ImagesPagedJSON },
      },
      DeleteImage: {
        name: "DeleteImage",
        handler: service.DeleteImage,
        input: { protobuf: base.Lookup, json: base.LookupJSON },
        output: { protobuf: base.Deleted, json: base.DeletedJSON },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Image = {
  /**
   * Serializes Image to protobuf.
   */
  encode: function (msg: PartialDeep<Image>): Uint8Array {
    return Image._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Image from protobuf.
   */
  decode: function (bytes: ByteSource): Image {
    return Image._readMessage(
      Image.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Image with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Image>): Image {
    return {
      imageUlid: "",
      image: "",
      originalHeight: 0,
      originalWidth: 0,
      top: 0,
      left: 0,
      scale: 0,
      cropHeight: 0,
      cropWidth: 0,
      siteUlid: "",
      dateCreated: "",
      dateModified: "",
      isProcessed: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Image>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.imageUlid) {
      writer.writeString(1, msg.imageUlid);
    }
    if (msg.image) {
      writer.writeString(2, msg.image);
    }
    if (msg.originalHeight) {
      writer.writeDouble(3, msg.originalHeight);
    }
    if (msg.originalWidth) {
      writer.writeDouble(4, msg.originalWidth);
    }
    if (msg.top) {
      writer.writeDouble(5, msg.top);
    }
    if (msg.left) {
      writer.writeDouble(6, msg.left);
    }
    if (msg.scale) {
      writer.writeDouble(7, msg.scale);
    }
    if (msg.cropHeight) {
      writer.writeDouble(8, msg.cropHeight);
    }
    if (msg.cropWidth) {
      writer.writeDouble(9, msg.cropWidth);
    }
    if (msg.siteUlid) {
      writer.writeString(10, msg.siteUlid);
    }
    if (msg.dateCreated) {
      writer.writeString(11, msg.dateCreated);
    }
    if (msg.dateModified) {
      writer.writeString(12, msg.dateModified);
    }
    if (msg.isProcessed) {
      writer.writeBool(13, msg.isProcessed);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Image, reader: protoscript.BinaryReader): Image {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.imageUlid = reader.readString();
          break;
        }
        case 2: {
          msg.image = reader.readString();
          break;
        }
        case 3: {
          msg.originalHeight = reader.readDouble();
          break;
        }
        case 4: {
          msg.originalWidth = reader.readDouble();
          break;
        }
        case 5: {
          msg.top = reader.readDouble();
          break;
        }
        case 6: {
          msg.left = reader.readDouble();
          break;
        }
        case 7: {
          msg.scale = reader.readDouble();
          break;
        }
        case 8: {
          msg.cropHeight = reader.readDouble();
          break;
        }
        case 9: {
          msg.cropWidth = reader.readDouble();
          break;
        }
        case 10: {
          msg.siteUlid = reader.readString();
          break;
        }
        case 11: {
          msg.dateCreated = reader.readString();
          break;
        }
        case 12: {
          msg.dateModified = reader.readString();
          break;
        }
        case 13: {
          msg.isProcessed = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Images = {
  /**
   * Serializes Images to protobuf.
   */
  encode: function (msg: PartialDeep<Images>): Uint8Array {
    return Images._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Images from protobuf.
   */
  decode: function (bytes: ByteSource): Images {
    return Images._readMessage(
      Images.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Images with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Images>): Images {
    return {
      images: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Images>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.images?.length) {
      writer.writeRepeatedMessage(1, msg.images as any, Image._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Images,
    reader: protoscript.BinaryReader,
  ): Images {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Image.initialize();
          reader.readMessage(m, Image._readMessage);
          msg.images.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ImagesPaged = {
  /**
   * Serializes ImagesPaged to protobuf.
   */
  encode: function (msg: PartialDeep<ImagesPaged>): Uint8Array {
    return ImagesPaged._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ImagesPaged from protobuf.
   */
  decode: function (bytes: ByteSource): ImagesPaged {
    return ImagesPaged._readMessage(
      ImagesPaged.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ImagesPaged with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ImagesPaged>): ImagesPaged {
    return {
      pagedInfo: base.PagedInfo.initialize(),
      records: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ImagesPaged>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.pagedInfo) {
      writer.writeMessage(1, msg.pagedInfo, base.PagedInfo._writeMessage);
    }
    if (msg.records?.length) {
      writer.writeRepeatedMessage(2, msg.records as any, Image._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ImagesPaged,
    reader: protoscript.BinaryReader,
  ): ImagesPaged {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.pagedInfo, base.PagedInfo._readMessage);
          break;
        }
        case 2: {
          const m = Image.initialize();
          reader.readMessage(m, Image._readMessage);
          msg.records.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ImageJSON = {
  /**
   * Serializes Image to JSON.
   */
  encode: function (msg: PartialDeep<Image>): string {
    return JSON.stringify(ImageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Image from JSON.
   */
  decode: function (json: string): Image {
    return ImageJSON._readMessage(ImageJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Image with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Image>): Image {
    return {
      imageUlid: "",
      image: "",
      originalHeight: 0,
      originalWidth: 0,
      top: 0,
      left: 0,
      scale: 0,
      cropHeight: 0,
      cropWidth: 0,
      siteUlid: "",
      dateCreated: "",
      dateModified: "",
      isProcessed: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Image>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.imageUlid) {
      json["imageUlid"] = msg.imageUlid;
    }
    if (msg.image) {
      json["image"] = msg.image;
    }
    if (msg.originalHeight) {
      json["originalHeight"] = msg.originalHeight;
    }
    if (msg.originalWidth) {
      json["originalWidth"] = msg.originalWidth;
    }
    if (msg.top) {
      json["top"] = msg.top;
    }
    if (msg.left) {
      json["left"] = msg.left;
    }
    if (msg.scale) {
      json["scale"] = msg.scale;
    }
    if (msg.cropHeight) {
      json["cropHeight"] = msg.cropHeight;
    }
    if (msg.cropWidth) {
      json["cropWidth"] = msg.cropWidth;
    }
    if (msg.siteUlid) {
      json["siteUlid"] = msg.siteUlid;
    }
    if (msg.dateCreated) {
      json["dateCreated"] = msg.dateCreated;
    }
    if (msg.dateModified) {
      json["dateModified"] = msg.dateModified;
    }
    if (msg.isProcessed) {
      json["isProcessed"] = msg.isProcessed;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Image, json: any): Image {
    const _imageUlid_ = json["imageUlid"] ?? json["image_ulid"];
    if (_imageUlid_) {
      msg.imageUlid = _imageUlid_;
    }
    const _image_ = json["image"];
    if (_image_) {
      msg.image = _image_;
    }
    const _originalHeight_ = json["originalHeight"] ?? json["original_height"];
    if (_originalHeight_) {
      msg.originalHeight = protoscript.parseDouble(_originalHeight_);
    }
    const _originalWidth_ = json["originalWidth"] ?? json["original_width"];
    if (_originalWidth_) {
      msg.originalWidth = protoscript.parseDouble(_originalWidth_);
    }
    const _top_ = json["top"];
    if (_top_) {
      msg.top = protoscript.parseDouble(_top_);
    }
    const _left_ = json["left"];
    if (_left_) {
      msg.left = protoscript.parseDouble(_left_);
    }
    const _scale_ = json["scale"];
    if (_scale_) {
      msg.scale = protoscript.parseDouble(_scale_);
    }
    const _cropHeight_ = json["cropHeight"] ?? json["crop_height"];
    if (_cropHeight_) {
      msg.cropHeight = protoscript.parseDouble(_cropHeight_);
    }
    const _cropWidth_ = json["cropWidth"] ?? json["crop_width"];
    if (_cropWidth_) {
      msg.cropWidth = protoscript.parseDouble(_cropWidth_);
    }
    const _siteUlid_ = json["siteUlid"] ?? json["site_ulid"];
    if (_siteUlid_) {
      msg.siteUlid = _siteUlid_;
    }
    const _dateCreated_ = json["dateCreated"] ?? json["date_created"];
    if (_dateCreated_) {
      msg.dateCreated = _dateCreated_;
    }
    const _dateModified_ = json["dateModified"] ?? json["date_modified"];
    if (_dateModified_) {
      msg.dateModified = _dateModified_;
    }
    const _isProcessed_ = json["isProcessed"] ?? json["is_processed"];
    if (_isProcessed_) {
      msg.isProcessed = _isProcessed_;
    }
    return msg;
  },
};

export const ImagesJSON = {
  /**
   * Serializes Images to JSON.
   */
  encode: function (msg: PartialDeep<Images>): string {
    return JSON.stringify(ImagesJSON._writeMessage(msg));
  },

  /**
   * Deserializes Images from JSON.
   */
  decode: function (json: string): Images {
    return ImagesJSON._readMessage(ImagesJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Images with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Images>): Images {
    return {
      images: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Images>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.images?.length) {
      json["images"] = msg.images.map(ImageJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Images, json: any): Images {
    const _images_ = json["images"];
    if (_images_) {
      for (const item of _images_) {
        const m = ImageJSON.initialize();
        ImageJSON._readMessage(m, item);
        msg.images.push(m);
      }
    }
    return msg;
  },
};

export const ImagesPagedJSON = {
  /**
   * Serializes ImagesPaged to JSON.
   */
  encode: function (msg: PartialDeep<ImagesPaged>): string {
    return JSON.stringify(ImagesPagedJSON._writeMessage(msg));
  },

  /**
   * Deserializes ImagesPaged from JSON.
   */
  decode: function (json: string): ImagesPaged {
    return ImagesPagedJSON._readMessage(
      ImagesPagedJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ImagesPaged with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ImagesPaged>): ImagesPaged {
    return {
      pagedInfo: base.PagedInfoJSON.initialize(),
      records: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ImagesPaged>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.pagedInfo) {
      const _pagedInfo_ = base.PagedInfoJSON._writeMessage(msg.pagedInfo);
      if (Object.keys(_pagedInfo_).length > 0) {
        json["pagedInfo"] = _pagedInfo_;
      }
    }
    if (msg.records?.length) {
      json["records"] = msg.records.map(ImageJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ImagesPaged, json: any): ImagesPaged {
    const _pagedInfo_ = json["pagedInfo"];
    if (_pagedInfo_) {
      base.PagedInfoJSON._readMessage(msg.pagedInfo, _pagedInfo_);
    }
    const _records_ = json["records"];
    if (_records_) {
      for (const item of _records_) {
        const m = ImageJSON.initialize();
        ImageJSON._readMessage(m, item);
        msg.records.push(m);
      }
    }
    return msg;
  },
};
