// Code generated by nerdynz/builder. DO NOT EDIT.
// versions:
// 	builder        v1.0.0
// source: {{.TableName}}.proto

package {{.TableName}}

import (
	"context"
	"errors"
	"slices"
	"strings"
	"time"

	base "github.com/nerdynz/skeleton/rpc/base"
	"github.com/nerdynz/datastore"
)

var clientHelperGlobal *{{.TableNamePascal}}Helper

type {{.TableNamePascal}}Helper struct {
	ds *datastore.Datastore
	// fieldNames []string
	// orderBy    string
}

func New{{.TableNamePascal}}Helper(datastore *datastore.Datastore) *{{.TableNamePascal}}Helper {
	if clientHelperGlobal == nil {
		clientHelperGlobal = new{{.TableNamePascal}}Helper(datastore)
	}
	return clientHelperGlobal
}

func new{{.TableNamePascal}}Helper(datastore *datastore.Datastore) *{{.TableNamePascal}}Helper {
	helper := &{{.TableNamePascal}}Helper{
		ds: datastore,
	}
	return helper
}

func (h *{{.TableNamePascal}}Helper) New(siteUlid string) *{{.TableNamePascal}} {
	record := &{{.TableNamePascal}}{}
	// check DateCreated
	record.DateCreated = time.Now().Format(time.RFC3339)
	record.SiteUlid = siteUlid
	return record
}

func (h *{{.TableNamePascal}}Helper) Load(ctx context.Context, ulid string) (*{{.TableNamePascal}}, error) {
	record, err := h.One(ctx, "where {{.TableUlid}} = $1 and $SITEULID", ulid)
	if err != nil {
		return nil, err
	}
	return record, nil
}

func (h *{{.TableNamePascal}}Helper) All(ctx context.Context) ([]*{{.TableNamePascal}}, error) {
	siteUlid := ctx.Value("site_ulid").(string)
	var records []*{{.TableNamePascal}}

	sql := h.selectFrom()
	sql += `where site_ulid = $1 order by ` + h.orderBy()

	err := h.ds.Select(ctx, &records, sql, siteUlid)
	if err != nil {
		return nil, err
	}
	return records, nil
}

func (h *{{.TableNamePascal}}Helper) Where(ctx context.Context, sql string, args ...interface{}) ([]*{{.TableNamePascal}}, error) {
	s := h.selectFrom()
	s += " " + sql + " "
	s += ` order by ` + h.orderBy() // NOTE: be careful sql inj
	s += " limit 1"

	records, err := h.SQL(ctx, s, args...)
	if err != nil {
		return nil, err
	}
	return records, nil
}

func (h *{{.TableNamePascal}}Helper) SQL(ctx context.Context, sql string, args ...interface{}) ([]*{{.TableNamePascal}}, error) {
	siteUlid := ctx.Value("site_ulid").(string)

	if !strings.Contains(sql, "$SITEULID") {
		return nil, errors.New("No $SITEULID placeholder defined")
	}
	var records []*{{.TableNamePascal}}
	sql, args, err := datastore.AppendSiteULID(siteUlid, sql, args...)
	if err != nil {
		return nil, err
	}
	err = h.ds.Select(ctx, &records, sql, args...)
	if err != nil {
		return nil, err
	}
	return records, nil
}

func (h *{{.TableNamePascal}}Helper) One(ctx context.Context, sql string, args ...interface{}) (*{{.TableNamePascal}}, error) {
	s := h.selectFrom()
	s += " " + sql + " "
	s += ` order by ` + h.orderBy() // NOTE: be careful sql inj
	s += " limit 1"

	records, err := h.SQL(ctx, s, args...)
	if err != nil {
		return nil, err
	}
	if len(records) != 1 {
		return nil, errors.New("Failed to fetch only one record")
	}
	return records[0], nil
}


func (h *{{.TableNamePascal}}Helper) PagedBy(ctx context.Context, pageNum int32, itemsPerPage int32, orderByFieldName string, direction string, searchText string) (*{{.TableNamePluralPascal}}Paged, error) {
	siteUlid := ctx.Value("site_ulid").(string)

	if orderByFieldName == "" || orderByFieldName == "default" {
		// we only want the first field name
		orderByFieldName = strings.Split(h.orderBy(), ",")[0]
		orderByFieldName = strings.Trim(orderByFieldName, " ")
	}

	// check the orderby exists within the fields as this could be an easy sql injection hole.
	if !slices.Contains(h.fieldNames(), orderByFieldName) { // NOT
		return nil, errors.New("field name [" + orderByFieldName + "]  isn't a valid field name")
	}

	direction = strings.ToLower(direction)
	if direction == "none" {
		direction = ""
	}
	if !(direction == "asc" || direction == "desc" || direction == "") {
		return nil, errors.New("direction isn't valid")
	}

	offset := (pageNum - 1) * itemsPerPage

	sql := h.selectFrom()
	sql += " where site_ulid = $1"
	if searchText == "" {
		sql += " and ($2='')"
	} else {
		sql += " and ($2 = '' or tsv @@ to_tsquery($2))"
	}

	// above does the sql injection check for this
	sql += " order by " + orderByFieldName + " " + direction

	sql += " offset $3 "
	sql += " limit $4 "

	var records []*{{.TableNamePascal}}
	err := h.ds.Select(ctx, &records, sql, siteUlid, datastore.FormatSearch(searchText), offset, itemsPerPage)
	if err != nil {
		return nil, err
	}

	dirEnum := base.PagedInfo_NONE
	switch strings.ToUpper(direction) {
	case base.PagedInfo_ASC.String():
		dirEnum = base.PagedInfo_ASC
	case base.PagedInfo_DESC.String():
		dirEnum = base.PagedInfo_DESC
	}

	count := int32(0)
	h.ds.One(ctx, &count, `select count({{.TableUlid}}) from {{.TableName}} where site_ulid = $1`, siteUlid)
	paged := &base.PagedInfo{
		PageNumber: pageNum,
		OrderBy:    orderByFieldName,
		Direction:  dirEnum,
		Limit:      itemsPerPage,
		Total:      count,
		Search:     searchText,
	}
	return &{{.TableNamePluralPascal}}Paged{
		PagedInfo: paged,
		Records:   records,
	}, nil
}

func (h *{{.TableNamePascal}}Helper) save(ctx context.Context, record *{{.TableNamePascal}}) error {
	siteUlid := ctx.Value("site_ulid").(string)
	err := h.beforeSave(record)
	if err != nil {
		return err
	}
	if record.SiteUlid != siteUlid {
		return errors.New("*{{.TableNamePascal}} update failed. SITEULID Mismatch")
	}
	sql := `
	INSERT INTO {{.TableName}} ({{.ColumnsCommaSeperated}}) 
	VALUES ({{.ColumnsCommaSeperatedPlaceholders}})
	ON CONFLICT ({{.TableULID}}) 
	DO UPDATE {{.ColumnsUpsertConflictPairs}}
	`
	_, err = h.ds.Exec(ctx, sql, {{.ColumnsRecordPrefixedStrings}})
	if err != nil {
		return err
	}
	err = h.afterSave(record)
	return err
}

func (h *{{.TableNamePascal}}Helper) Delete(ctx context.Context, recordUlid string) (bool, error) {
	siteUlid := ctx.Value("site_ulid").(string)
	result, err := h.ds.Exec(ctx, `
	DELETE FROM {{.TableName}}  
	WHERE site_ulid=$1 and {{.TableUlid}}=$2
	`, siteUlid, recordUlid)
	if err != nil {
		return false, err
	}
	return (result.RowsAffected() > 0), nil
}

{{$tableNameCame := .TableNameCamel}}{{$tableName := .TableName}}{{$TableNamePascal := .TableNamePascal}}{{$TableULID := .TableULID}}
{{range $index, $child := .Children}}<!--
-->//func ({{$tableNameCame}} *{{$TableNamePascal}}) Save{{$child.PluralName}}(siteUlid string) error {
//	return {{$child.TableName}}Helper().SaveMany(siteUlid, {{$tableNameCame}}.{{$child.PluralName}})
//}
//
//func ({{$tableNameCame}} *{{$TableNamePascal}}) Load{{$child.PluralName}}(siteUlid string) error {
//	return {{$tableNameCame}}.Load{{$child.PluralName}}Where(siteUlid, "{{$TableULID}} = $1 $SITEULID", {{$tableNameCame}}.{{$TableNamePascal}}ULID)
//}
//
//func ({{$tableNameCame}} *{{$TableNamePascal}}) Load{{$child.PluralName}}Where(siteUlid string, sql string, args ...interface{}) error {
//	children, err := {{$child.TableName}}Helper().Where(siteUlid, sql, args...)
//	if err != nil {
//		return err
//	}
//	{{$tableNameCame}}.{{$child.PluralName}} = children
//	return nil
//}
{{end}}