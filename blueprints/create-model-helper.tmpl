// Code generated by nerdynz/builder. DO NOT EDIT.
// versions:
// 	builder        v1.0.0
// source: {{.TableName}}.proto

package {{.TableName}}

import (
	"context"
	"errors"
	"slices"
	"strings"
	"time"

	base "github.com/nerdynz/skeleton/rpc/base"
	"github.com/nerdynz/datastore"
)

var {{.TableNameCamel}}HelperGlobal *{{.TableNamePascal}}Helper

type {{.TableNamePascal}}Helper struct {
	ds       *datastore.Datastore
	siteUlid string
	ctx      context.Context
}

func New{{.TableNamePascal}}Helper(datastore *datastore.Datastore) *{{.TableNamePascal}}Helper {
	if {{.TableNameCamel}}HelperGlobal == nil {
		{{.TableNameCamel}}HelperGlobal = new{{.TableNamePascal}}Helper(datastore)
	}
	return {{.TableNameCamel}}HelperGlobal
}

func {{.TableNamePascal}}Helper(ctx context.Context, datastore *datastore.Datastore) *{{.TableNameCamel}}Helper {
	return new{{.TableNamePascal}}Helper(ctx, datastore)
}

func new{{.TableNamePascal}}Helper(ctx context.Context, datastore *datastore.Datastore) *{{.TableNameCamel}}Helper {
	siteUlid := ctx.Value("SiteUlid").(string)
	helper := &{{.TableNameCamel}}Helper{
		ds: datastore,
		siteUlid: siteUlid,
		ctx:     ctx,
	}
	return helper
}

func (h *{{.TableNameCamel}}Helper) selectFrom() string {
	return `
	SELECT 
		` + strings.Join(h.fieldNames(), ", ") + `
	FROM 
		{{.TableName}}
	`
}

func (h *{{.TableNameCamel}}Helper) New() *{{.TableNamePascal}} {
	record := &{{.TableNamePascal}}{}
	// check DateCreated
	record.DateCreated = time.Now().Format(time.RFC3339)
	record.SiteUlid = h.siteUlid
	return record
}

func (h *{{.TableNameCamel}}Helper) Load(ulid string) (*{{.TableNamePascal}}, error) {
	record, err := h.One("where {{.TableUlid}} = $1 and $SITEULID", ulid)
	if err != nil {
		return nil, err
	}
	return record, nil
}

func (h *{{.TableNameCamel}}Helper) All() ([]*{{.TableNamePascal}}, error) {
	siteUlid := h.ctx.Value("SiteUlid").(string)
	var records []*{{.TableNamePascal}}

	sql := h.selectFrom()
	sql += `where site_ulid = $1 order by ` + h.orderBy()

	err := h.ds.Select(h.ctx, &records, sql, siteUlid)
	if err != nil {
		return nil, err
	}
	return records, nil
}

func (h *{{.TableNameCamel}}Helper) Where(sql string, args ...interface{}) ([]*{{.TableNamePascal}}, error) {
	s := h.selectFrom()
	s += " " + sql + " "
	s += ` order by ` + h.orderBy()

	records, err := h.SQL(s, args...)
	if err != nil {
		return nil, err
	}
	return records, nil
}

func (h *{{.TableNameCamel}}Helper) SQL(sql string, args ...interface{}) ([]*{{.TableNamePascal}}, error) {
	siteUlid := h.ctx.Value("SiteUlid").(string)

	if !strings.Contains(sql, "$SITEULID") {
		return nil, errors.New("No $SITEULID placeholder defined")
	}
	var records []*{{.TableNamePascal}}
	sql, args, err := datastore.AppendSiteULID(siteUlid, sql, args...)
	if err != nil {
		return nil, err
	}
	err = h.ds.Select(h.ctx, &records, sql, args...)
	if err != nil {
		return nil, err
	}
	return records, nil
}

func (h *{{.TableNameCamel}}Helper) One(sql string, args ...interface{}) (*{{.TableNamePascal}}, error) {
	s := h.selectFrom()
	s += " " + sql + " "
	s += ` order by ` + h.orderBy() // NOTE: be careful sql inj
	s += " limit 1"

	records, err := h.SQL(s, args...)
	if err != nil {
		return nil, err
	}
	if len(records) != 1 {
		return nil, errors.New("Failed to fetch only one record")
	}
	return records[0], nil
}


func (h *{{.TableNameCamel}}Helper) PagedBy(pageNum int, itemsPerPage int, orderByFieldName string, direction string, searchText string) (*{{.TableNamePluralPascal}}Paged, error) {
	if orderByFieldName == "" || orderByFieldName == "default" {
		// we only want the first field name
		orderByFieldName = strings.Split(h.orderBy(), ",")[0]
		orderByFieldName = strings.Trim(orderByFieldName, " ")
	}

	// check the orderby exists within the fields as this could be an easy sql injection hole.
	if !slices.Contains(h.fieldNames(), orderByFieldName) { // NOT
		return nil, errors.New("field name [" + orderByFieldName + "]  isn't a valid field name")
	}

	direction = strings.ToLower(direction)
	if direction == "none" {
		direction = ""
	}
	if !(direction == "asc" || direction == "desc" || direction == "") {
		return nil, errors.New("direction isn't valid")
	}

	offset := (pageNum - 1) * itemsPerPage

	sql := h.selectFrom()
	sql += " where site_ulid = $1"
	if searchText == "" {
		sql += " and ($2='')"
	} else {
		sql += " and ($2 = '' or tsv @@ to_tsquery($2))"
	}

	// above does the sql injection check for this
	sql += " order by " + orderByFieldName + " " + direction

	sql += " offset $3 "
	sql += " limit $4 "

	var records []*{{.TableNamePascal}}
	err := h.ds.Select(h.ctx, &records, sql, h.siteUlid, datastore.FormatSearch(searchText), offset, itemsPerPage)
	if err != nil {
		return nil, err
	}
	count := 0
	h.ds.One(h.ctx, &count, `select count({{.TableUlid}}) from {{.TableName}} where site_ulid = $1`, h.siteUlid)
	paged := &PagedInfo{
		PageNumber: pageNum,
		OrderBy:    orderByFieldName,
		Direction:  PagedInfoDirectionFromStr(direction),
		Limit:      itemsPerPage,
		Total:      count,
		Search:     searchText,
	}
	return &{{.TableNamePluralPascal}}Paged{
		PagedInfo: paged,
		Records:   records,
	}, nil
}

func (h *{{.TableNameCamel}}Helper) Save(record *{{.TableNamePascal}}) error {
	return h.saveMany([]*{{.TableNamePascal}}{record})
}
func (h *{{.TableNameCamel}}Helper) SaveMany(records []*{{.TableNamePascal}}) error {
	return h.saveMany(records)
}

func (h *{{.TableNameCamel}}Helper) saveMany(records []*{{.TableNamePascal}}) error {
	for _, record := range records {
		err := h.beforeSave(record)
		if err != nil {
			return err
		}
		if record.SiteUlid != h.siteUlid {
			return errors.New("*{{.TableNamePascal}} update failed. SITEULID Mismatch")
		}
	}

	sqlPlaceholders := make([]string, 0)
	vals := make([]interface{}, 0)
	for i, record := range records {
		field := i * {{.ColumnsLength}}
		sqlPlaceholders = append(sqlPlaceholders, {{.ColumnsSprintfCommaSeperatedPlaceholders}})
		vals = append(vals, {{.ColumnsRecordPrefixedStrings}})
	}
	sql := `
	INSERT INTO {{.TableName}} ({{.ColumnsCommaSeperated}})
	VALUES 
	` + strings.Join(sqlPlaceholders, ",") + `
	ON CONFLICT ({{.TableULID}}) 
	DO UPDATE {{.ColumnsUpsertConflictPairs}}
	`
	_, err := h.ds.Exec(h.ctx, sql, vals...)
	if err != nil {
		return err
	}
	for _, record := range records {
		err = h.afterSave(record)
		if err != nil {
			return err
		}
	}
	return nil
}

func (h *{{.TableNameCamel}}Helper) Delete(recordUlid string) (bool, error) {
	siteUlid := h.ctx.Value("SiteUlid").(string)
	result, err := h.ds.Exec(h.ctx, `
	DELETE FROM {{.TableName}}  
	WHERE site_ulid=$1 and {{.TableUlid}}=$2
	`, siteUlid, recordUlid)
	if err != nil {
		return false, err
	}
	return (result.RowsAffected() > 0), nil
}

{{$tableNameCame := .TableNameCamel}}{{$tableName := .TableName}}{{$TableNamePascal := .TableNamePascal}}{{$TableULID := .TableULID}}
{{range $index, $child := .Children}}<!--
-->//func ({{$tableNameCame}} *{{$TableNamePascal}}) Save{{$child.PluralName}}(siteUlid string) error {
//	return {{$child.TableName}}Helper().SaveMany(siteUlid, {{$tableNameCame}}.{{$child.PluralName}})
//}
//
//func ({{$tableNameCame}} *{{$TableNamePascal}}) Load{{$child.PluralName}}(siteUlid string) error {
//	return {{$tableNameCame}}.Load{{$child.PluralName}}Where(siteUlid, "{{$TableULID}} = $1 $SITEULID", {{$tableNameCame}}.{{$TableNamePascal}}ULID)
//}
//
//func ({{$tableNameCame}} *{{$TableNamePascal}}) Load{{$child.PluralName}}Where(siteUlid string, sql string, args ...interface{}) error {
//	children, err := {{$child.TableName}}Helper().Where(siteUlid, sql, args...)
//	if err != nil {
//		return err
//	}
//	{{$tableNameCame}}.{{$child.PluralName}} = children
//	return nil
//}
{{end}}